package dev.hycompanion.plugin.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import dev.hycompanion.plugin.core.npc.NpcData;
import dev.hycompanion.plugin.utils.PluginLogger;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Instant;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Stream;

/**
 * Manages NPC configuration files cached locally
 * 
 * NPC data is synced from the backend and stored as JSON5 files.
 * These serve as a cache and offline reference.
 */
public class NpcConfigManager {

    private final Path cacheDirectory;
    private final PluginLogger logger;
    private final Gson gson;

    // In-memory cache of NPC data
    private final Map<String, NpcData> npcCache = new ConcurrentHashMap<>();

    public NpcConfigManager(Path cacheDirectory, PluginLogger logger) {
        this.cacheDirectory = cacheDirectory;
        this.logger = logger;
        this.gson = new GsonBuilder()
                .setPrettyPrinting()
                .disableHtmlEscaping()
                .registerTypeAdapter(Instant.class, new InstantTypeAdapter())
                .create();

        // Create directory if not exists
        try {
            Files.createDirectories(cacheDirectory);
        } catch (IOException e) {
            logger.error("Failed to create NPC cache directory", e);
        }
    }

    /**
     * Load all cached NPC configs from disk
     */
    public void loadAll() {
        try (Stream<Path> files = Files.list(cacheDirectory)) {
            files.filter(p -> p.toString().endsWith(".json") || p.toString().endsWith(".json5"))
                    .forEach(this::loadNpcFile);

            logger.info("Loaded " + npcCache.size() + " cached NPCs from disk");
        } catch (IOException e) {
            logger.error("Failed to load NPC cache", e);
        }
    }

    /**
     * Save all NPCs to disk
     */
    public void saveAll() {
        npcCache.values().forEach(this::saveNpc);
        logger.debug("Saved " + npcCache.size() + " NPCs to cache");
    }

    /**
     * Get NPC data by external ID
     */
    public Optional<NpcData> getNpc(String externalId) {
        return Optional.ofNullable(npcCache.get(externalId));
    }

    /**
     * Get all cached NPCs
     */
    public Map<String, NpcData> getAllNpcs() {
        return Map.copyOf(npcCache);
    }

    /**
     * Add or update an NPC from sync
     */
    public void upsertNpc(NpcData npc) {
        NpcData updatedNpc = npc.withSyncedAt(Instant.now());
        npcCache.put(npc.externalId(), updatedNpc);
        saveNpc(updatedNpc);
        logger.debug("NPC upserted: " + npc.externalId() + " (" + npc.name() + ")");
    }

    /**
     * Remove an NPC
     */
    public void removeNpc(String externalId) {
        npcCache.remove(externalId);

        try {
            Path filePath = cacheDirectory.resolve(sanitizeFilename(externalId) + ".json5");
            Files.deleteIfExists(filePath);
            logger.debug("NPC removed: " + externalId);
        } catch (IOException e) {
            logger.error("Failed to delete NPC cache file", e);
        }
    }

    /**
     * Load a single NPC file
     */
    private void loadNpcFile(Path path) {
        try {
            String content = Files.readString(path);
            // Simple JSON5 â†’ JSON conversion (remove comments)
            String json = convertJson5ToJson(content);
            NpcData npc = gson.fromJson(json, NpcData.class);

            if (npc != null && npc.externalId() != null) {
                npcCache.put(npc.externalId(), npc);
            }
        } catch (Exception e) {
            logger.warn("Failed to load NPC file: " + path.getFileName());
        }
    }

    /**
     * Save an NPC to disk
     */
    private void saveNpc(NpcData npc) {
        try {
            String filename = sanitizeFilename(npc.externalId()) + ".json5";
            Path filePath = cacheDirectory.resolve(filename);

            // Add JSON5 header comment
            String header = "// " + npc.name() + "\n// This file is auto-generated by sync - DO NOT EDIT MANUALLY\n";
            String json = gson.toJson(npc);

            Files.writeString(filePath, header + json);
        } catch (IOException e) {
            logger.error("Failed to save NPC: " + npc.externalId(), e);
        }
    }

    /**
     * Convert JSON5 to standard JSON (simple comment removal)
     */
    private String convertJson5ToJson(String json5) {
        // Remove single-line comments
        String result = json5.replaceAll("//[^\\n]*", "");
        // Remove multi-line comments
        result = result.replaceAll("/\\*[^*]*\\*+(?:[^/*][^*]*\\*+)*/", "");
        // Remove trailing commas before } or ]
        result = result.replaceAll(",\\s*([}\\]])", "$1");
        return result;
    }

    /**
     * Sanitize filename from external ID
     */
    private String sanitizeFilename(String externalId) {
        return externalId.replaceAll("[^a-zA-Z0-9_-]", "_").toLowerCase();
    }

    /**
     * Custom TypeAdapter for java.time.Instant
     * Avoids reflection issues with Java 25's module system
     */
    private static class InstantTypeAdapter extends TypeAdapter<Instant> {
        @Override
        public void write(JsonWriter out, Instant value) throws IOException {
            if (value == null) {
                out.nullValue();
            } else {
                out.value(value.toString()); // ISO-8601 format
            }
        }

        @Override
        public Instant read(JsonReader in) throws IOException {
            if (in.peek() == com.google.gson.stream.JsonToken.NULL) {
                in.nextNull();
                return null;
            }
            String text = in.nextString();
            return Instant.parse(text);
        }
    }
}
